<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>bearjaw.dev</title><description>Doing swifty things 1-bit at a time üöÄ</description><link>https://bearjaw.dev</link><language>en</language><lastBuildDate>Mon, 28 Apr 2025 19:53:26 +0200</lastBuildDate><pubDate>Mon, 28 Apr 2025 19:53:26 +0200</pubDate><ttl>250</ttl><atom:link href="https://bearjaw.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://bearjaw.dev/posts/2025/04/Exploring_AsyncSteams</guid><title>Exploring AsyncStreams ‚Äì Part 1</title><description>In this little segment I'll share some insights I learned after exploring how AsyncStream can be tool for Swift Concurrency safe reactive programming.</description><link>https://bearjaw.dev/posts/2025/04/Exploring_AsyncSteams</link><pubDate>Sat, 26 Apr 2025 12:00:00 +0200</pubDate><content:encoded><![CDATA[<p>I hadn't used <code><span class="type">AsyncStream</span></code> much since it was first introduced in Swift 5.5.<br>With Swift 6 now out in the wild, it felt like enough time had passed to see whether it could be an addition ‚Äî or even replace ‚Äî Combine in my daily dev life.</p><h2>Small discalaimer</h2><p>Personally, I like writing simple code. Ideally, it should be testable, easy to read, and easy to reason about. The code examples below are simplified to quickly try out some concepts. This post is mostly about exploring how <code><span class="type">AsyncStream</span></code> could fit into the apps I write or work on.</p><h2>Reactive programming with Combine</h2><p>Combine offers reactive programming in a very neat way. Quite often, you can simply use the property wrapper <code><span class="keyword">@Published</span></code> and subscribe to it with <code>$</code> and <code><span class="call">sink</span>(<span class="keyword">_</span>:)</code>:</p><pre><code><span class="keyword">@MainActor
final class</span> BookStore {
    <span class="keyword">@Published
    private(set) var</span> books: [<span class="type">Book</span>] = []
}

<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
    <span class="keyword">private let</span> store = <span class="type">BookStore</span>()
    <span class="keyword">private var</span> disposables = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        store.<span class="property">$books</span>.<span class="call">sink</span> { <span class="keyword">_ in</span>
            <span class="comment">// Update the dataSource</span>
        }.<span class="call">store</span>(in: &amp;disposables)
    }
}
</code></pre><p>Writing reactive code with Combine feels very easy and straightforward. Combine also offers a lot of powerful functions to modify the stream. It even offers an AsyncStream publisher! Plus, the Apple developer community has added even more convenient open-source extensions and custom Publishers.</p><h2>Streams</h2><p><code><span class="type">AsyncStream</span></code> can offer an alternative that feels almost like an extension to the Swift language itself, making it a natural companion for Swift's concurrency features.<br>Let's look at a simple example of observing a stream of values over time:</p><pre><code><span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
    <span class="keyword">private let</span> store = <span class="type">BookStore</span>()
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="type">Task</span> { <span class="keyword">await</span> <span class="call">observeBooks</span>() }
    }
    
    <span class="keyword">private func</span> observeBooks() <span class="keyword">async</span> {
        <span class="keyword">for await</span> books <span class="keyword">in</span> store.<span class="property">stream</span> {
            <span class="comment">// Update snapshot</span>
        }
    }
}
</code></pre><p>Observing books from the store now reads like a simple <code><span class="keyword">for in</span></code> loop that we already know. No need to capture <code><span class="keyword">self</span></code> anywhere or keep track of a cancellable (yet).<br><br>However, the downside is that we had to introduce a <code><span class="type">Task</span></code>, which breaks a little of the straightforwardness. In SwiftUI this is much easier as you can use the <code><span class="call">task</span>()</code> view modifier.</p><p>The code above, while looking clean, is actually quite dangerous. With <code><span class="type">AsyncStream</span></code>, it is important to finish the stream.</p><p>This makes sense because <code><span class="keyword">for await</span></code> is a suspension point, and without ending it properly, the view controller will never be deallocated.</p><p>Thus, we need to adjust our subscription strategy. We'll now resubscribe once the view is added to the view hierarchy and cancel the subscription once the view is removed.<br><br>By calling <code><span class="call">cancel</span>()</code> on the task we can end the stream. Additionally you can cancel a stream after meeting a condition by using either <code><span class="keyword">return</span></code> or <code><span class="keyword">break</span></code>.<br>The difference is:</p><ul><li><code><span class="keyword">break</span></code> executes any code following the <code><span class="keyword">for await</span></code> loop.</li><li><code><span class="keyword">return</span></code> ends the function immediately.</li></ul><pre><code><span class="keyword">final class</span> UniverseBookViewController: <span class="type">UIViewController</span> {
    <span class="keyword">private let</span> store = <span class="type">BookStore</span>()
    <span class="keyword">private var</span> task: <span class="type">Task</span>&lt;<span class="type">Void</span>, <span class="type">Never</span>&gt;?
    
    <span class="keyword">override func</span> viewDidAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
        <span class="keyword">super</span>.<span class="call">viewDidAppear</span>(animated)
        view.<span class="property">backgroundColor</span> = .<span class="dotAccess">white</span>
        task = <span class="type">Task</span> { <span class="keyword">await</span> <span class="call">observeBooks</span>() }
    }
    
    <span class="keyword">override func</span> viewDidDisappear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
        <span class="keyword">super</span>.<span class="call">viewDidDisappear</span>(animated)
        task?.<span class="call">cancel</span>()
    }
    
    <span class="keyword">private func</span> observeBooks() <span class="keyword">async</span> {
        <span class="keyword">for await</span> books <span class="keyword">in</span> store.<span class="property">stream</span> {
            <span class="keyword">if let</span> book = books.<span class="call">first</span>(where: { $0.<span class="property">title</span> == <span class="string">"The wonders of the universe"</span> }) {
                <span class="comment">// Update the view with our book</span>
                <span class="call">print</span>(book)
                <span class="comment">// Using a return or a break can also cancel a stream.</span>
                <span class="keyword">return</span>
            } <span class="keyword">else</span> {
                <span class="comment">// Keep waiting</span>
                <span class="call">print</span>(books)
            }
        }
    }
}
</code></pre><p>Another important thing to remember is that finishing a stream doesn't necessarily end the fetching of new data. You'll need to explicity stop any work you're doing. You can implement a <code>onTermination</code> handler and stop any polling or timers.</p><pre><code>continuation.<span class="property">onTermination</span> = { [<span class="keyword">weak self</span>] reason <span class="keyword">in
    self</span>?.<span class="call">stopPolling</span>()
}
</code></pre><p>Another major difference compared to using <code><span class="keyword">@Published</span></code> is that when you subscribe to an <code><span class="type">AsyncStream</span></code>, <strong>you don't receive any initial values by default</strong>.<br><br>So let's look at how to create a stream in the first place.</p><h2>Bring your own stream!</h2><p>One important thing to keep in mind about <code><span class="type">AsyncStream</span></code> is that <strong>you can only have one subscriber per stream</strong>. So, you need to return a <strong>new instance</strong> for each new subscriber and then keep the continuation which makes finishing a stream explicitly a bit difficult.</p><pre><code><span class="keyword">@MainActor
final class</span> BookStore {
    ...

    <span class="keyword">private var</span> continuations: [<span class="type">AsyncStream</span>&lt;[<span class="type">Book</span>]&gt;.<span class="type">Continuation</span>] = []

    <span class="keyword">var</span> stream: <span class="type">AsyncStream</span>&lt;[<span class="type">Book</span>]&gt; {
        <span class="type">AsyncStream</span> { continuation <span class="keyword">in
            self</span>.<span class="property">continuations</span>.<span class="call">append</span>(continuation)
        }
    }
    ...
}
</code></pre><p>To emit values over time, you work with the <code><span class="type">Continuation</span></code> object. In this case, we store the continuation so that we can yield new values when needed.</p><p>In Swift 5.9, Swift introduced a nice little convenience initializer:</p><pre><code><span class="keyword">var</span> stream: <span class="type">AsyncStream</span>&lt;[<span class="type">Book</span>]&gt; {
    <span class="keyword">let</span> container = <span class="type">AsyncStream</span>.<span class="call">makeStream</span>(of: [<span class="type">Book</span>].<span class="keyword">self</span>)
    <span class="keyword">self</span>.<span class="property">continuations</span>.<span class="call">append</span>(container.<span class="property">continuation</span>)
    <span class="keyword">return</span> container.<span class="property">stream</span>
}
</code></pre><p>With this new handy <code>makeStream</code> method we can get rid of the closure which improves the readability for my taste. However we can only access this in iOS 17 and equivalent other platforms.</p><p>To emit values, you use <code><span class="call">yield</span>(<span class="keyword">_</span>:)</code>:</p><pre><code><span class="keyword">func</span> newBook(<span class="keyword">_</span> title: <span class="type">String</span>, author: <span class="type">String</span>) {
    <span class="keyword">let</span> book = <span class="type">Book</span>(title: title, author: author)
    books.<span class="call">append</span>(book)
    <span class="keyword">for</span> continuation <span class="keyword">in</span> continuations {
        continuation.<span class="call">yield</span>(books)
    }
}
</code></pre><p>You <strong>can't</strong> access the current value of an <code><span class="type">AsyncStream</span></code>. You can only <em>await</em> its next value. If you need to access the latest data at any time, you'll have to keep a separate buffer yourself.</p><p>If you want to emit a value immediately after someone subscribes, you can call <code><span class="call">yield</span>(<span class="keyword">_</span>:)</code> right after creating the stream.</p><h2>Some observations</h2><p>I'd say <code><span class="type">AsyncStream</span></code> is definitely an interesting tool to have. Especially when paired with <a href="https://github.com/apple/swift-async-algorithms?tab=readme-ov-file">Swift Async Algorithms</a>.<br>However, I don't think it currently serves as a full replacement for Combine.</p><p>First of all, it's very easy to shoot yourself in the foot by accidentally forgetting to finish the stream.<br>In SwiftUI, you can easily tie an <code><span class="type">AsyncStream</span></code>‚Äôs lifecycle to the SwiftUI view‚Äôs lifecycle, making it much easier to use.<br><br>In UIKit, however, you need to manually manage subscriptions and cancellations using <code><span class="type">UIViewController</span></code> lifecycle methods.<br><br>You also need to ensure your code still behaves correctly even when the view controller presents another view controller on top.</p><p>I am still only scratching the surface but I can see that I could find some usage for streams going forward.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bearjaw.dev/posts/2024/05/Testable%20networking%20code%20-%20Part%202</guid><title>Testable Networking Code ‚Äì Part 2</title><description>In this part 2 we're looking at how to leverage protocols to make your networking code testable.</description><link>https://bearjaw.dev/posts/2024/05/Testable%20networking%20code%20-%20Part%202</link><pubDate>Sat, 4 May 2024 12:00:00 +0200</pubDate><content:encoded><![CDATA[<h2>Introduction</h2><p>There are many paths you can take to make your code testable, especially when it comes to networking.</p><p>In this part, I'll walk through how to leverage protocols to improve testability.<br>Instead of having an <code><span class="type">APIService</span></code> class or struct that directly performs requests, we'll create a simple protocol, a mock APIService, and make both conform to the protocol.</p><hr><h2>Defining a Protocol</h2><pre><code><span class="keyword">protocol</span> APIRequestable {
    <span class="keyword">func</span> performRequest&lt;T: <span class="type">Decodable</span>&gt;(<span class="keyword">_</span> request: <span class="type">APIRequest</span>&lt;<span class="type">T</span>&gt;) <span class="keyword">async throws</span> -&gt; <span class="type">T</span>
}

<span class="comment">// Implementation</span>
<span class="keyword">final class</span> APIServiceMock: <span class="type">APIRequestable</span> {
    <span class="keyword">func</span> performRequest&lt;T: <span class="type">Decodable</span>&gt;(<span class="keyword">_</span> request: <span class="type">APIRequest</span>&lt;<span class="type">T</span>&gt;) <span class="keyword">async throws</span> -&gt; <span class="type">T</span> {
        <span class="call">fatalError</span>(<span class="string">"TODO: Implement"</span>)
    }
}
</code></pre><p>This looks easy and reusable. Now you can use APIRequestable in your real and test implementations by implementing both the real service and a mock version. Instead of depending directly on APIService, you‚Äôll depend on the protocol.</p><p>For simplicity let's use the poor man's dependency injection:</p><pre><code><span class="keyword">final class</span> UserProfileViewModel {

    <span class="keyword">private let</span> apiService: <span class="type">APIRequestable</span>
    <span class="keyword">private var</span> user: <span class="type">User</span>?
    
    <span class="keyword">init</span>(apiService: <span class="type">APIRequestable</span>) {
        <span class="keyword">self</span>.<span class="property">apiService</span> = apiService
    }
    
    <span class="keyword">func</span> fetchCurrentUser() <span class="keyword">async throws</span> {
        <span class="keyword">let</span> request = <span class="type">APIEndpoint</span>.<span class="type">User</span>.<span class="call">current</span>()
        user = <span class="keyword">try await</span> apiService.<span class="call">performRequest</span>(request)
    }
    
    <span class="keyword">func</span> greeting() -&gt; <span class="type">String</span> {
    <span class="keyword">if let</span> user {
        <span class="keyword">return</span> <span class="string">"Hello,</span> \(name)<span class="string">!"</span>
    }
        <span class="keyword">return</span> <span class="string">"Hello!"</span>
    }
}

...

<span class="comment">// In your test</span>
<span class="keyword">func</span> test_fetches_currentUser() <span class="keyword">async throws</span> {
    <span class="keyword">let</span> mockAPIService = <span class="type">APIServiceMock</span>()
    <span class="keyword">let</span> sut = <span class="type">UserProfileViewModel</span>(apiService: mockAPIService)
    <span class="keyword">try await</span> sut.<span class="call">fetchCurrentUser</span>()
    <span class="keyword">let</span> expectedGreeting = <span class="string">"Hello, Tim!"</span>
    <span class="keyword">let</span> greeting = sut.<span class="call">greeting</span>()
    <span class="call">XCTAssertEqual</span>(greeting, expectedGreeting)
} 

</code></pre><h2>An approach and a problem</h2><p>While writing a mock can be very little work we're running into a small problem with our networking layer or data pipeline. We're not really in control of the data. Or at least it's very inflexible as we have to return different data per endpoint or even chain endpoints.</p><p>Another common approach is to create a protocol for the <code><span class="type">UserProfileViewModel</span></code>, implement <code><span class="keyword">func</span> loadCurrentUser() <span class="keyword">async throws</span></code> and always return a user or create another mock and throw an error. You could even inject the response you want this method to return here as well.</p><p>So let's do that quickly (We could also just use Swift's <code><span class="type">Result</span></code> type):</p><pre><code><span class="keyword">enum</span> UserTestAPIResponse {
    <span class="keyword">case</span> user(<span class="type">User</span>)
    <span class="keyword">case</span> error(<span class="type">Error</span>)
}
</code></pre><p>Then we can create a mock class of the ViewModel, implement the protocol to fetch the current user, and return the injected API response.</p><pre><code><span class="keyword">let</span> testResponse: <span class="type">UserTestAPIResponse</span>
...
<span class="keyword">func</span> loadCurrentUser() <span class="keyword">async throws</span> {
    <span class="keyword">switch</span> testResponse {
        <span class="keyword">case let</span> user(user): 
            <span class="keyword">self</span>.<span class="property">user</span> = user
    <span class="keyword">case let</span> error(error):
            <span class="keyword">throw</span> error
    }
}
   
<span class="comment">// In your test</span>
<span class="keyword">func</span> test_fetches_currentUser() <span class="keyword">async throws</span> {
    <span class="keyword">let</span> expectedUser = <span class="type">User</span>(name: <span class="string">"Tim"</span>)
    <span class="keyword">let</span> response = <span class="type">UserTestAPIResponse</span>.<span class="call">user</span>(expectedUser)
    
    <span class="keyword">let</span> sut = <span class="type">UserProfileViewModelMock</span>(fetchUserResponse: response)

    <span class="keyword">try await</span> sut.<span class="call">loadCurrentUser</span>()
    
    <span class="keyword">let</span> expectedGreeting = <span class="string">"Hello, Tim!"</span>
    <span class="keyword">let</span> greeting = sut.<span class="call">greeting</span>()
    <span class="call">XCTAssertEqual</span>(greeting, expectedGreeting)
} 
</code></pre><p>Now the test will pass again and we're happy but the way we got there is not great, we're also not really testing anything, and it doesn't scale.</p><p>It looks pretty flexible until you realise that you probably have more than one api call in your viewModel. You'll probably need more responses. Some api calls might be chained. You could create a dictionary and create a unique key for each api call and return it's response. Additionally we had to copy our implementation of <code><span class="call">greeting</span>()</code>. Not really DRY and what if our real implementation of <code><span class="call">greeting</span>()</code> ever changes?</p><p>So, now you might say subclassing to the rescue! Again, something you could do and you might not have to duplicate your code that way but I do prefer composition if possible over inheritance.</p><p>It becomes clear we don't really test our viewModel code but rather test a different part of code using a mock version of our viewModel. Depending on what we want to test we're forced to duplicate our real implementation code.</p><p>It's a lot of overhead and and a lot of mocks and classes you need to write. You'll spend more time setting up your mock pipeline than writing tests.</p><p>One thing to keep in mind is generally in blog posts or tutorials, the code is always super clean, easy to read, and very small. So while it looks trivial and small it could grow quite fast and we'll also need to maintain our mocks and our responses.</p><h2>A better way?</h2><p>Let's go back to the APIService. It's a better option to put the all the heavy lifting code we need to return the correct responses we want to test in our APIServiceMock implementation. However we'll end up in the same situation as with our ViewModel. We're not really testing our real networking / api layer here. We're testing a mock implementation of it.</p><pre><code><span class="comment">// In your test</span>
<span class="keyword">func</span> test_fetches_currentUser() <span class="keyword">async throws</span> {
    <span class="keyword">let</span> expectedUser = <span class="type">User</span>(name: <span class="string">"Tim"</span>)
    <span class="keyword">let</span> response = <span class="type">UserTestAPIResponse</span>.<span class="call">user</span>(expectedUser)
    <span class="keyword">let</span> mockAPIService = <span class="type">UserAPIServiceMock</span>(response: response)
    
    <span class="keyword">let</span> sut = <span class="type">UserProfileViewModel</span>(apiService: mockAPIService)
    
    <span class="keyword">try await</span> sut.<span class="call">fetchCurrentUser</span>()
    
    <span class="keyword">let</span> expectedGreeting = <span class="string">"Hello, Tim!"</span>
    <span class="keyword">let</span> greeting = sut.<span class="call">greeting</span>()
    <span class="call">XCTAssertEqual</span>(greeting, expectedGreeting)
} 
</code></pre><p>This approach is a lot better as we no longer have to copy the real implementation of our ViewModel or Model and instead leverage our mock to return the response we want. We also cover the real implementation of our ViewModel with our tests and we no longer need to keep the mock in sync with our actual implementation.</p><h2>Conclusion</h2><p>Protocols are a great tool to abstract away concrete types and make your code testable. However, they can also introduce a lot of boilerplate if you‚Äôre not careful.</p><p>When choosing this approach I found that it's easier to write tests and iterate if I can control the data rather than the UI layer (ViewModel). It might seem irrelvant but if you mock the data pipeline then you only have to write a mock for the service. You could even implement a mock per test.</p><p>In a future post I'll leverage my favourite way to take control over the data pipeline.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bearjaw.dev/posts/2023/2/build-testable-networking-part-1</guid><title>Testable networking code ‚Äì Part 1</title><description>This is part 1 of a small series explaining how I made an existing networking stack testable</description><link>https://bearjaw.dev/posts/2023/2/build-testable-networking-part-1</link><pubDate>Sat, 18 Feb 2023 12:00:00 +0100</pubDate><content:encoded><![CDATA[<h2>A smallish intro</h2><p>If you browse job listings for iOS developers or generally for developers testability is always highlighted as very important. Clean architecture, writing tests have become buzzwords in the industry. Unfortunately it happens that when you get to peek behind the curtains you discover that there are no tests, the code is tightly coupled, and the task of even introducing tests feels impossible and you're left wondering why you jumped through all those hoops.</p><p>To be fair I haven't seen all the code bases in the world so this is purely based on my experiences and chats with other developers. I am sure there are many companies where tests are just as important as the features developers have to write.</p><p>I strongly support writing testable, well readable code and well also writing tests. I think what really helped me become a better developer and write better code was to venture out into different fields. At my joby job we tired to re-write our mobile app using a cross platform framework. There were many reason that went into this and my awesome colleague Catalin wrote a really great <a href="https://catalincodes.com/posts/when-to-use-nativescript">blog post</a> about how that went and why decided not to (thankfully) ditch our native apps.</p><p>While I really disliked the whole cross platform work itself it did teach me quite a lot much. I learned a new stack and was able to also start contributing to our Angular based website. The main point however is that we had a very thorough test driven development approach and it was the one thing I really longed for when getting back to working on the iOS app.</p><p>I already added some tests for some newer parts and features of the code base but due to the architecture and the massive code base I was never really able to make our existing ViewModels at least a bit more testable. However reinvigorated with my new knowledge I decided to give this a new try.</p><h2>Assembling the pieces</h2><p>So that was a long intro. Let's write some code. The app uses Alamofire under the hood so some of the code is specific to it but it's also quite easy to roll or apply this to your own networking stack. For that reason I decided to write a small wrapper around Alamofire and some of its features so it could be possible in the future to actually exchange the networking stack completely.</p><p>I started by abstracting away the actual method call we use to perform networking requests. For this I created an <code><span class="type">APIService</span></code> that would eventually make the request and handle the decoding. Generally the APIService is only used by a new <code><span class="type">Repository</span></code> class that would have the APIService injected into it.</p><p>The APIService itself needs a <code><span class="type">Session</span></code> and this is basically Alamofire's main class to make networking requests. Now this can't easily be abstracted away. You could create a protocol and add the <code><span class="call">request</span>()</code> method and make Session then conform to it but I wasn't convinced that it would bring much value for something that will not change for a very long time. And if it does you only have to fix it in one single place.</p><p>I did however write wrapper types Alamofire's <code><span class="type">HTTPMethod</span></code>, <code><span class="type">ParameterEncoding</span></code>, and <code><span class="type">HTTPHeaders</span></code>. Mainly because you'll be using these every time you create an APIRequest and believe me, we have quite a few.</p><pre><code><span class="keyword">struct</span> APIService {
    
    <span class="keyword">private let</span> session: <span class="type">Session</span>

    <span class="keyword">init</span>(session: <span class="type">Session</span>) {
        <span class="keyword">self</span>.<span class="property">session</span> = session
    }

     <span class="keyword">func</span> request&lt;T&gt;(request: <span class="type">APIRequest</span>&lt;<span class="type">T</span>&gt;,
                completion: <span class="keyword">@escaping</span> (<span class="type">Result</span>&lt;<span class="type">T</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Decodable</span> {
        session
            .<span class="call">request</span>(request.<span class="property">url</span>,
                     method: request.<span class="property">method</span>.<span class="property">alamofireMethod</span>,
                     parameters: request.<span class="property">parameters</span>,
                     encoding: request.<span class="property">alamofireEncoding</span>
            )
            .<span class="call">responseData</span> { response <span class="keyword">in</span>
                <span class="comment">// handle response</span>
            }
    }
}
</code></pre><p>For simplicity I omitted the wrappers. Another goal of mine was to tie the response type to the request. This is easily achieved by leveraging generics and conforming <code><span class="type">T</span></code> to <code><span class="type">Decodable</span></code>. In the app I will not initialise any APIRequest in let's say a ViewModel or a Service. APIRequest come packaged in their API domain which are defined by enums. You'll see in a bit further down how it works.</p><p>The APIRequest struct is defined follows:</p><pre><code><span class="keyword">struct</span> APIRequest&lt;T: <span class="type">Decodable</span>&gt;  {

    <span class="keyword">let</span> url: <span class="type">String</span>
    <span class="keyword">let</span> method: <span class="type">HTTPMethod</span>
    <span class="keyword">let</span> parameters: <span class="type">Parameters</span>?
    <span class="keyword">let</span> encoding: <span class="type">ParameterEncoding</span>
    <span class="keyword">let</span> headers: <span class="type">HTTPHeaders</span>?

    <span class="keyword">init</span>(url: <span class="type">String</span>,
         method: <span class="type">HTTPMethod</span> = .<span class="dotAccess">GET</span>,
         parameters: <span class="type">Parameters</span>? = <span class="keyword">nil</span>,
         encoding: <span class="type">ParameterEncoding</span> = .<span class="dotAccess">urlDefault</span>,
         headers: <span class="type">HTTPHeaders</span>? = <span class="keyword">nil</span>) {
        <span class="keyword">self</span>.<span class="property">url</span> = url
        <span class="keyword">self</span>.<span class="property">method</span> = method
        <span class="keyword">self</span>.<span class="property">parameters</span> = parameters
        <span class="keyword">self</span>.<span class="property">encoding</span> = encoding
        <span class="keyword">self</span>.<span class="property">headers</span> = headers
    }

}
</code></pre><p>Now the last piece of the puzzle is the Repository. Before I started to incrementally introduce the new API approach, each API domain had it's own specific repository implementation. That created a lot of duplicated code. Basically the only thing that really changes are requests. That's why I created a general repository class that would eventually be used by the app to make API requests. The session <code>apiClient</code> is just a global property that returns the production session by default. Alamofire's default session is a singleton so I am not introducing anything fancy here.</p><pre><code><span class="keyword">final class</span> Repository {

    <span class="keyword">private let</span> httpClient: <span class="type">APIService</span>

    <span class="keyword">init</span>(httpClient: <span class="type">APIService</span> = <span class="type">APIService</span>(session: apiClient)) {
        <span class="keyword">self</span>.<span class="property">httpClient</span> = httpClient
    }

    <span class="keyword">func</span> performRequest&lt;T&gt;(<span class="keyword">_</span> request: <span class="type">APIRequest</span>&lt;<span class="type">T</span>&gt;,
                           completion: <span class="keyword">@escaping</span> (<span class="type">Result</span>&lt;<span class="type">T</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Decodable</span> {
        httpClient.<span class="call">request</span>(request: request, completion: completion)
    }

    <span class="keyword">deinit</span> {
        <span class="type">LoggingService</span>.<span class="property">networking</span>.<span class="call">log_debug</span>(message: <span class="string">"\n\n Deinit:</span> \(<span class="call">type</span>(of: <span class="keyword">self</span>)) <span class="string">\n\n"</span>)
    }

}
</code></pre><p>In addition to that I decided to move our API domains into enums and having static methods to create the APIRequest. This makes it quite nice to use. Let's assume I want to get the current user:</p><pre><code><span class="keyword">extension</span> <span class="type">APIEndpoint</span> {

    <span class="keyword">enum</span> User {

        <span class="keyword">private static let</span> baseURL = <span class="string">"api.some.domain.com"</span>

        <span class="comment">// MARK: - Me</span>

        <span class="keyword">static func</span> currentUser() -&gt; <span class="type">APIRequest</span>&lt;<span class="type">User</span>&gt; {
            <span class="keyword">let</span> url = <span class="string">"</span>\(baseURL)<span class="string">)/users/current"</span>
            <span class="keyword">return</span> <span class="type">APIRequest</span>(url: url)
        }

}

<span class="comment">// somewhere in your code</span>
<span class="keyword">let</span> request = <span class="type">APIEndpoint</span>.<span class="type">User</span>.<span class="call">currentUser</span>()
repository.<span class="call">performRequest</span>(request) { result <span class="keyword">in
    switch</span> result {
        <span class="keyword">case let</span> .<span class="call">success</span>(user):
            <span class="call">print</span>(<span class="string">"Hello</span> \(user.<span class="property">firstName</span>)<span class="string">"</span>)
        <span class="keyword">case let</span> .<span class="call">failue</span>(error):
            <span class="call">print</span>(<span class="string">"Oh no, an error:</span> \(error.<span class="property">localizedDescription</span>)<span class="string">"</span>)
    }
}
</code></pre><h2>Testing requests</h2><p>After all the pieces of the puzzle have finally fallen into place it's time to write some tests.</p><p>First, like I did in Angular, I wanted to test my requests. This ensures that the correct url is used, the right parameters are included and so on.</p><p>To do this I created a simple extension on <code><span class="type">XCTestCase</span></code>. The extension is simply to reduce writing duplicate code and assertions. It also makes it easily extensible again.</p><pre><code>  <span class="keyword">func</span> testRequest&lt;T&gt;(<span class="keyword">_</span> request: <span class="type">APIRequest</span>&lt;<span class="type">T</span>&gt;,
                    <span class="keyword">_</span> expectedRequest: <span class="type">APIRequest</span>&lt;<span class="type">T</span>&gt;,
                    matchParams: ((<span class="type">Parameters</span>?) -&gt; <span class="type">Bool</span>)? = <span class="keyword">nil</span>,
                    matchHeaders: ((<span class="type">HTTPHeaders</span>?) -&gt; <span class="type">Bool</span>)? = <span class="keyword">nil</span>) {

        <span class="keyword">if let</span> matchHeaders {
            <span class="call">XCTAssertTrue</span>(<span class="call">matchHeaders</span>(request.<span class="property">headers</span>))
        } <span class="keyword">else</span> {
            <span class="call">XCTAssertNil</span>(request.<span class="property">headers</span>)
        }
        <span class="keyword">if let</span> matchParams {
            <span class="call">XCTAssertTrue</span>(<span class="call">matchParams</span>(request.<span class="property">parameters</span>))
        } <span class="keyword">else</span> {
            <span class="call">XCTAssertNil</span>(request.<span class="property">parameters</span>)
        }

        <span class="call">XCTAssertEqual</span>(request, expectedRequest, <span class="call">errorMessage</span>(got: request, expected: expectedRequest))
    }
</code></pre><p>Now you can easily write a test to make you everything is set up correctly.</p><pre><code><span class="keyword">final class</span> UserRepositoryTests: <span class="type">XCTestCase</span> {

    <span class="keyword">func</span> test_current_user_request() {
        <span class="keyword">let</span> request = <span class="type">APIEndpoint</span>
            .<span class="dotAccess">User</span>
            .<span class="call">currentUser</span>()

        <span class="keyword">let</span> expectedURL = <span class="string">"someURL"</span>
        <span class="keyword">let</span> expectedRequest = <span class="type">APIRequest</span>&lt;<span class="type">Empty</span>&gt;(url: expectedURL)

        <span class="call">testRequest</span>(request, expectedRequest)
    }
}
</code></pre><p>That's it for now. In part 2 I will explain how I test the repository itself, making sure the responses are decoded properly. All of this is also doable with <code><span class="keyword">async</span> / <span class="keyword">await</span></code>. However we still support older iOS versions and can't use that yet but the implementation is pretty much the same. Once we finally move to iOS 13 and upwards the whole code will be even nicer to write.</p><p>Thanks for reading üê∂</p>]]></content:encoded></item><item><guid isPermaLink="true">https://bearjaw.dev/posts/2023/1/hello</guid><title>Autolayout Wrapper</title><description>A brief dive into writing a wrapper around AutoLayout</description><link>https://bearjaw.dev/posts/2023/1/hello</link><pubDate>Sun, 29 Jan 2023 12:00:00 +0100</pubDate><content:encoded><![CDATA[<h1>Autolayout Wrapper</h1><h3><em>Disclaimer</em>:</h3><p><em>Yes, there are a lot of AutoLayout wrappers available. This is mainly me writing down my approach of creating a thin, lightweight, and flexible wrapper around AutoLayout.</em></p><h2>Some considerations</h2><p>There are many AutoLayout wrappers out there. A project that I worked on recently used <a href="https://github.com/SnapKit/SnapKit">SnapKit</a>. And while there‚Äôs nothing wrong with using third-party dependencies, I prefer to learn and understand Apple‚Äôs APIs first and then write a thin wrapper around it myself to make my life easier. It also saves you from adding another third-party-dependency to your app.</p><p>Now you could say why am I even bothering with all these old APIs and technologies and not use SwiftUI instead? Well, SwiftUI has only been around since iOS 13 which kind of limits your usage of SwiftUI in production if your app still needs to support older versions of iOS.</p><p>In personal projects I did start to experiment a little with SwiftUI but so far UIKit has been a good friend to me. There‚Äôs also no point in discussing whether you should <em>only</em> use or learn one or the other. Like many already pointed out it depends on what you want to do and they complement each other quite well.</p><h2>Time travel</h2><p>When I started out as an iOS developer AutoLayout wasn‚Äôt a thing yet, so I used to calculate my views‚Äô origins and sizes manually like this:</p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">final class</span> MyView: <span class="type">UIView</span> {

    <span class="keyword">private let</span> label = <span class="type">UILabel</span>()
    
    ...
    <span class="keyword">override func</span> layoutSubviews() {
        <span class="keyword">super</span>.<span class="call">layoutSubviews</span>()
        <span class="keyword">let</span> origin = ...
        <span class="keyword">let</span> size = ...
        label.<span class="property">frame</span> = <span class="type">CGRect</span>(origin: origin, size: size)
    }
    ...
}
</code></pre><p>While this method works well and can be quite efficient when it comes to rendering, it is definitely more verbose and time consuming than SwiftUI or AutoLayout (Once you finally get a hang of it). Another thing to keep in mind is that by calculating your frames directly, ideally dynamically, your UI probably wouldn't support right-to-left languages properly.</p><p>It took me quite some time to become familiar with AutoLayout. The API seems very cumbersome and heavy to use. To me most of the methods felt counterintuitive and seemed to do the opposite of what I expected. It definitely got better once we got <code>anchors</code> in iOS 9. However debugging AutoLayout is a mess and time consuming. There‚Äôs a reason why <a href="_https://www.wtfautolayout.com_">WTFAutoLayout</a> exists.</p><p>Sometimes it‚Äôs easy and you only forgot to set <code>view.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span></code>. Other times the height and vertical position are ambiguous and it seems impossible to grasp why. Also it's important to remember to call <code>constraint.<span class="property">active</span> = <span class="keyword">true</span></code> to actually tell the OS that it should use and evaluate that constraint. That‚Äôs quite a lot of things you always have to do and remember. It proved therefore quite useful to create a thin wrapper around common AutoLayout functionality.</p><p>This can slow your development velocity down quite a bit. At the same time you might not always have the luxury to sit down and develop your own libraries to fix these issues during your day to day job. What you can do though is introduce this process step by step. Every time you find yourself writing a specific UI building block you could extract the code into a reusable function.</p><h2>Putting it all together</h2><p>One of the problems of AutoLayout is that when using constraints you need to remember to set <code>translatesAutoresizingMaskIntoConstraints</code> to <code><span class="keyword">false</span></code>. You can make your life easier by leveraging property wrappers. I really liked this option. It makes it clear to anyone reading your code that this view is using constraints and that our favourite property has already been set to <code><span class="keyword">false</span></code>. Property wrappers in general are an amazing tool to have in Swift.</p><pre><code><span class="keyword">@propertyWrapper
struct</span> AutoLayoutable&lt;T: <span class="type">UIView</span>&gt; {
    <span class="keyword">var</span> wrappedValue: <span class="type">T</span> {
        <span class="keyword">didSet</span> {
            wrappedValue.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
        }
    }
    
    <span class="keyword">init</span>(wrappedValue: <span class="type">T</span>) {
        <span class="keyword">self</span>.<span class="property">wrappedValue</span> = wrappedValue
        wrappedValue.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
    }
}
</code></pre><p>However there are some drawbacks with this. You can‚Äôt really use <code><span class="keyword">lazy var</span></code> with property wrappers which could be an issue if you‚Äôre looking to squeeze out as much efficiency as possible from your views. The most efficient view is the one that isn‚Äôt rendered. You also can't use <code><span class="keyword">let</span></code>s. Depending on your coding style and / or your needs it could be better to manually set the value.</p><h3>Example</h3><pre><code><span class="keyword">final class</span> DetailView: <span class="type">UIView</span> {

    <span class="keyword">@AutoLayoutable
    private var</span> labelTitle = <span class="type">UILabel</span>()

    <span class="keyword">@AutoLayoutable
    private var</span> labelSubtitle = <span class="type">UILabel</span>()
    
}
</code></pre><p>One thing that bothered me with Apple's AutoLayout API is that it just feels heavy and hard to read. Coming from Objective-C where methods were always quite expressive and stated clear intent, my wrapper therefore had to be declaritive and readable as well.</p><p>By using <code><span class="call">pinToTop</span>(of:space:priority)</code> it became much clearer to me what I wanted to achieve without getting too much into the details of how I want to achieve it. Another idea I took into consideration was to actually have my constraints be expressible using <code><span class="keyword">enum</span></code>s. That has the advantage of reducing the number of methods you'd need to memorise and use. You could maybe pass an array of anchors that would then translate to the correct constraints.</p><p>I still might refactor my current version to a more enum driven one. For now I wanted to keep things simple. The implementation of <code>pinToTop</code> is pretty straightforward:</p><pre><code><span class="keyword">extension</span> <span class="type">UIView</span> {
    
    <span class="keyword">@discardableResult
    func</span> pinToTop(of view: <span class="type">UIView</span>,
                  space: <span class="type">CGFloat</span>,
                  priority: <span class="type">UILayoutPriority</span> = .<span class="dotAccess">defaultHigh</span>) -&gt; <span class="type">NSLayoutConstraint</span> {
        <span class="keyword">let</span> constraint = topAnchor.<span class="call">constraint</span>(equalTo: view.<span class="property">topAnchor</span>, constant: space)
        constraint.<span class="property">priority</span> = priority
        constraint.<span class="property">isActive</span> = <span class="keyword">true
        return</span> constraint
    }
    
}
</code></pre><p>One thing I noticed is that sometimes you need to adjust the constant or activate or deactivate your constraints. Using <code><span class="keyword">@discardableResult</span></code> and returing the constraint solves that issue quite well. Now you can get a reference to the constraint and animate a UI change for example.</p><p>Usually you also want some kind of spacing between two UI elements. The constant for trailling, bottom anchors uses a negative value and for top, leading uses positive values. Again this little <em>quirk</em> in AutoLayout is something that makes sense once you understand that it reflects the coordinate system of the OS. To make my life easier I only use positive values on the call site and my implementation handles the cases correctly.</p><h2>Conclusion</h2><p>I didn't include all extensions I created but the rest follow the same pattern so it's quite easy to extend and maintain. My layout code went from a lot of repetitive code to one liners:</p><pre><code><span class="keyword">private func</span> configureConstraints() {
    titleLabel.<span class="call">pinToTop</span>(of: <span class="keyword">self</span>, space: spacer4)
    titleLabel.<span class="call">pinToSides</span>(of: <span class="keyword">self</span>, space: spacer4)
    detailLabel.<span class="call">pinTopToBottom</span>(of: <span class="keyword">self</span>, space: spacer2)
    detailLabel.<span class="call">pinToSides</span>(of: <span class="keyword">self</span>, space: spacer4)
    detailLabel.<span class="call">pinToBottom</span>(of: <span class="keyword">self</span>, space: spacer4)
}
</code></pre><p>This increased my speed in creating a completely new UIs immensely. Not only that but I gained a lot of readability and clear intend. Of course AutoLayout offers a lot more functionality and not everything is covered by my small library yet. But it also doesn't have to be complete. Since it's just an extension on UIView I can add functionality anytime I need it.</p><p>Since I adapted my small wrapper my broken AutoLayout constraints nearly vanished. There are still cases where you do need to scratch your head a little and think about content hugging priorities and compress resistances but that's also what keeps things interesting.</p><p>Thanks for reading! üê∂</p>]]></content:encoded></item></channel></rss>